worker_processes auto;
error_log /var/log/openresty/error.log warn;
pid /usr/local/openresty/nginx/logs/nginx.pid;

events {
  worker_connections 1024;
  use epoll;
  multi_accept on;
}

http {
  lua_package_path "/usr/local/openresty/lualib/?.lua;;";
  default_type application/octet-stream;
  access_log /var/log/openresty/access.log;
  server_tokens off;
  more_clear_headers Server;
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;

  # Resolver for Docker DNS (use Docker's internal DNS)
  resolver 127.0.0.11 valid=30s ipv6=off;

  server {
    listen 8080;
    server_name _;

    # Health check endpoint
    location /health {
      return 200 'OK';
      add_header Content-Type text/plain;
    }

    # Runtime proxy: /runtime/{conversation_id}/{port}/...
    # Routes to sandbox container IP:port via Docker bridge network
    location ~ ^/runtime/(?<conv_id>[a-f0-9]+)/(?<target_port>\d+)(?<remaining_path>/.*)?$ {
      set $container_ip "";
      set $internal_port "";
      set $proxy_path $remaining_path;
      if ($proxy_path = "") {
        set $proxy_path "/";
      }

      access_by_lua_block {
        local discovery = require "docker_discovery"
        local function can_connect(ip, port)
          local p = tonumber(port)
          if not ip or not p then
            return false
          end
          local sock = ngx.socket.tcp()
          sock:settimeout(100)
          local ok = sock:connect(ip, p)
          if ok then
            sock:close()
            return true
          end
          sock:close()
          return false
        end

        local function is_browser_probe()
          local h = ngx.req.get_headers()
          local origin = h["origin"]
          if not origin then
            return false
          end
          -- The OpenHands UI does CORS probes to runtime hosts; these should not
          -- spam the console when the app isn't running yet.
          local mode = h["sec-fetch-mode"]
          if mode and mode ~= "cors" then
            return false
          end
          local accept = h["accept"] or ""
          return accept:find("application/json", 1, true) ~= nil
        end

        -- Get user_id from request header (injected by Lambda@Edge after JWT verification)
        local headers = ngx.req.get_headers()
        local request_user_id = headers["x-cognito-user-id"]

        local ip, port, container_user_id = discovery.find_container(ngx.var.conv_id, ngx.var.target_port)
        if ip and port then
          -- Verify ownership: container user_id must match requesting user
          -- NOTE: OpenHands core must add "user_id" label when creating sandbox containers
          -- If container has no user_id label, we allow access (backwards compatibility during rollout)
          if container_user_id and container_user_id ~= "" then
            if not request_user_id or request_user_id ~= container_user_id then
              ngx.log(ngx.WARN, "Access denied: user ", request_user_id or "anonymous", " tried to access container owned by ", container_user_id)
              ngx.status = 403
              ngx.say("Access denied: you do not own this conversation")
              return ngx.exit(403)
            end
            ngx.log(ngx.INFO, "Ownership verified: user ", request_user_id, " owns container ", ngx.var.conv_id)
          else
            ngx.log(ngx.WARN, "Container has no user_id label, allowing access (legacy container)")
          end

          -- If the upstream port isn't accepting connections yet:
          -- - For browser CORS probes from the OpenHands UI, return 204 so Chrome
          --   does not emit noisy "Failed to load resource" console errors.
          -- - For direct navigations, keep 502 to surface the problem.
          if not can_connect(ip, port) then
            if is_browser_probe() then
              ngx.status = 204
              ngx.header["Cache-Control"] = "no-store"
              ngx.log(ngx.INFO, "Probe: upstream not ready for ", ngx.var.conv_id, " port=", port, " (requested=", ngx.var.target_port, ")")
              return ngx.exit(204)
            end
            ngx.log(ngx.WARN, "Upstream not reachable for conversation: ", ngx.var.conv_id, " port=", port, " (requested=", ngx.var.target_port, ")")
            ngx.status = 502
            ngx.say("Upstream not reachable for conversation " .. ngx.var.conv_id)
            return ngx.exit(502)
          end

          ngx.var.container_ip = ip
          ngx.var.internal_port = port
          ngx.log(ngx.INFO, "Routing /runtime/", ngx.var.conv_id, "/", ngx.var.target_port, " to ", ip, ":", port)
        else
          ngx.log(ngx.WARN, "No container found for conversation: ", ngx.var.conv_id)
          ngx.status = 502
          ngx.say("No container found for conversation " .. ngx.var.conv_id)
          return ngx.exit(502)
        end
      }

      proxy_pass http://$container_ip:$internal_port$proxy_path$is_args$args;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_connect_timeout 60s;
      proxy_send_timeout 300s;
      proxy_read_timeout 300s;
      proxy_buffering off;
    }

    # Default: proxy to OpenHands app on port 3000
    location / {
      proxy_pass http://openhands:3000;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_connect_timeout 60s;
      proxy_send_timeout 300s;
      proxy_read_timeout 300s;
      proxy_buffering off;
    }
  }
}
